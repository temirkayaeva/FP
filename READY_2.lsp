; 1. Определите FUNCALL через функционал APPLY.

(defun -funcall (функция &rest аргументы) 
    (cond
        ((null аргументы) nil)
        (t (apply функция аргументы)
          )
        )
    )

(print(-funcall `* 1 2 3 4))


; 3. Определите функционал(APL-APPLY f x), который применяет каждую функ-цию fi списка(f1 f2 ... fn) к соответствующему 
; элементу спискаx = (x1 x2 ... xn) и возвращает список, сформированный из результатов.

(defun apl-apply (список-функций список-элементов)
  (cond 
      ((null список-функций) nil) 
      ((null список-элементов) nil)
        (t (cons (funcall (car список-функций) (car список-элементов))
               (apl-apply (cdr список-функций) (cdr список-элементов))))))


(print(apl-apply `(car cadr cdr) `((1 4 6) (1 2 3) (6 8 9))))

; 5. Определите функциональный предикат (НЕКОТОРЫЙ пред список), который истинен, когда, являющейся функциональным 
; аргументом предикат пред истинен хотя бы для одного элемента списка список.

(defun некоторый (пред список)
  (not (null 
        (mapcan
         #' (lambda (x)
         (if (funcall пред x)
             (list t) nil))
         список)
        )
       )
    )

(print (некоторый (lambda (x) (not (= x 1))) '(1 1 1 1 1 1)))
(print (некоторый (lambda (x) (not (= x 1))) '(1 1 1 0 1 1)))
